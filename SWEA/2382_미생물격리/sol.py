'''
정사각형 구역 안에 K개의 미생물 군집이 있다.
이 구역은 가로 N개, 세로 N개, 총 N * N 개의 동일한 크기의 정사각형 셀들로 이루어져 있다.
미생물들이 구역을 벗어나는걸 방지하기 위해, 가장 바깥쪽 가장자리 부분에 위치한 셀들에는 특수한 약품이 칠해져 있다.

① 최초 각 미생물 군집의 위치와 군집 내 미생물의 수, 이동 방향이 주어진다. 약품이 칠해진 부분에는 미생물이 배치되어 있지 않다. 이동방향은 상, 하, 좌, 우 네 방향 중 하나이다.

② 각 군집들은 1시간마다 이동방향에 있는 다음 셀로 이동한다.

③ 미생물 군집이 이동 후 약품이 칠해진 셀에 도착하면 군집 내 미생물의 절반이 죽고, 이동방향이 반대로 바뀐다.
    미생물 수가 홀수인 경우 반으로 나누어 떨어지지 않으므로, 다음과 같이 정의한다.
    살아남은 미생물 수 = 원래 미생물 수를 2로 나눈 후 소수점 이하를 버림 한 값 -> 몫
       따라서 군집에 미생물이 한 마리 있는 경우 살아남은 미생물 수가 0이 되기 때문에, 군집이 사라지게 된다,

④ 이동 후 두 개 이상의 군집이 한 셀에 모이는 경우 군집들이 합쳐지게 된다.
    합쳐 진 군집의 미생물 수는 군집들의 미생물 수의 합이며,
    이동 방향은 군집들 중 미생물 수가 가장 많은 군집의 이동방향이 된다.
    합쳐지는 군집의 미생물 수가 같은 경우는 주어지지 않으므로 고려하지 않아도 된다.

M 시간 동안 이 미생물 군집들을 격리하였다. M시간 후 남아 있는 미생물 수의 총합을 구하여라.

미생물 군집의 정보는 세로 위치, 가로 위치, 미생물 수, 이동 방향 순으로 4개의 정수가 주어진다.

2. 구역의 모양은 정사각형으로 주어지며, 한 변의 셀의 개수 N은 5이상 100이하의 정수이다. (5 ≤ N ≤ 100)
3. 최초 배치되어 있는 미생물 군집의 개수 K는 5이상 1,000이하의 정수이다. (5 ≤ K ≤ 1,000)
4. 격리 시간 M은 1이상 1,000이하의 정수이다. (1 ≤ M ≤ 1,000)
5. 최초 약품이 칠해진 가장자리 부분 셀에는 미생물 군집이 배치되어 있지 않다.
6. 최초에 둘 이상의 군집이 동일한 셀에 배치되는 경우는 없다.
7. 각 군집 내 미생물 수는 1 이상 10,000 이하의 정수이다.
8. 군집의 이동방향은 상하좌우 4방향 중 한 방향을 가진다. (상: 1, 하: 2, 좌: 3, 우: 4)
9. 주어진 입력으로 진행하였을 때, 동일한 셀에 같은 미생물 수를 갖는 두 군집이 모이는 경우는 발생하지 않는다.
10.  각 군집의 정보는 세로 위치, 가로 위치, 미생물 수, 이동 방향 순으로 주어진다. 각 위치는 0번부터 시작한다.
'''

import sys
sys.stdin = open('sample_input.txt')

T = int(input())

N, M, K = map(int, input().split())

clus = [list(map(int, input().split())) for _ in range(K)]
mat = [[0]*N for _ in range(N)]



for i in clus:
    mat[i[0]][i[1]] = [i[2], i[3]]


for i in range(M):
    for j in range(len(clus)): # 이동한 좌표를 clus에 저장
        if clus[j][3] == 1:
            clus[j][0] -= 1
        elif clus[j][3] == 2:
            clus[j][0] += 1
        elif clus[j][3] == 3:
            clus[j][1] -= 1
        else:
            clus[j][1] += 1

        # 이동 결과좌표가 0,6을 포함하고 있으면 방향을 반대로하고 미생물 절삭
        if clus[j][1] == 0 or clus[j][1] == N-1 or clus[j][0] == 0 or clus[j][0] == N-1:
            clus[j][2] = clus[j][2] // 2
            if clus[j][3] == 1:
                clus[j][3] = 2
            elif clus[j][3] == 2:
                clus[j][3] = 1
            elif clus[j][3] == 3:
                clus[j][3] = 4
            else:
                clus[j][3] = 3



    # clus를 순회하면서 같은 좌표를 가지고 있으면 합치고 방향은 가장 큰놈으로
    clus.sort(key=lambda x: (-x[2]))  # 미생물 수가 많은 순으로 정렬

    merged = []
    used = [False] * len(clus)
    
    for j in range(len(clus)):
        if used[j] or clus[j][2] == 0:  # 이미 합쳐졌거나 미생물이 0이면 스킵
            continue
        
        # 현재 군집의 정보
        row, col, count, direction = clus[j]
        
        # 같은 좌표에 있는 다른 군집들을 찾아서 합치기
        for k in range(j + 1, len(clus)):
            if not used[k] and clus[k][0] == row and clus[k][1] == col:
                count += clus[k][2]  # 미생물 수 합치기
                used[k] = True  # 합쳐진 군집 표시
        
        # 미생물이 0보다 크면 merged에 추가
        if count > 0:
            merged.append([row, col, count, direction])
    
    clus = merged  # 합쳐진 결과로 업데이트

